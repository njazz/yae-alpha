<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>yae wasm - alpha</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #1e1e1e;
      color: white;
    }

    body, #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding: 10px;
      box-sizing: border-box;
    }

    #topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 60px; /* between 40-80px */
      margin-bottom: 10px;
    }

    #buttons {
      display: flex;
      gap: 10px;
    }

    #scope {
      background: black;
      border: 1px solid #555;
      width: 250px;
      height: 50px;
    }

    #editor {
      flex-grow: 1;
      border: 1px solid #555;
      border-radius: 4px;
      overflow: hidden;
    }
  </style>
</head>
<body>

<div id="app" class="container-fluid d-flex flex-column p-0">
  <div id="appname" class="w-100">
    yae: yet another environment | alpha
    <hr style="margin-bottom: 0px; margin-top: 3px">
  </div>  
  <div id="topbar" class="w-100">
    <div id="buttons" class="btn-group" role="group" aria-label="Audio controls">
      <button id="startAudio" type="button" class="btn btn-primary">Start Audio</button>
      <button id="stopAudio" type="button" class="btn btn-danger" disabled>Stop Audio</button>
    </div>
    <canvas id="scope"></canvas>
  </div>

  <div id="editor"></div>
</div>

<!-- Scripts -->
<script src="yae_lca_core_wasm.js"></script>
<script src="https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js"></script>
<script>
  "use strict";

  // Initialize Monaco Editor
  require.config({ paths: { vs: 'https://unpkg.com/monaco-editor@0.45.0/min/vs' }});
  let yModule, engine, bufferIn, bufferOut;
  let audioContext, scriptNode;
  let isAudioRunning = false;



  require(["vs/editor/editor.main"], function () {
    const editor = monaco.editor.create(document.getElementById('editor'), {
      value: `@def ph() = @[Saw(2.05) ~*1.0]
@def bd() = @[

~+/{@[
ph() ~-_ Lt(0.25)
ADSR(0.005 0.02 0.0 0.0 ) ~*0.5 ~tanh ~*1.3
]
@[~~0 ~*0.05]
}
~~L 
~*@[ph() ~-_ Lt(0.5) ~*ADSR(0.05 0.01 0.0 0.0 ) ] ~*4.0 ]

@def hh() = @[
ph() ~-_ Gt(0.5) ADSR(0.01 0.05 0.0 0.0 ) ~tanh ~*~% ~*2
]
@def bass1() = @[
ph() ~-_ Gt(0.5)
ADSR(0.05 0.01 0.0 0.1 ) ~*@[~\\37 ~*0.15 ~~L] ~*2.0]

@def bass2() = @[
ph() ~-_ Gt(0.75)
ADSR(0.05 0.0 0.0 0.1 ) ~*@[~\\76 @[~*0.15 ~~0.97 ~-_ ~*0.15] ~~L ]  ~*1.0]

@def techno() = 

@/{bd() hh() bass1() bass2()}

@def v1()= @[
~+/{ 
@[~~440 
~*~~0.25 
]
~~0.3
}
~*0.5
Tanh()
~~L 
~*~~20 
~*~~0.05 
~~L 
~*0.50
]

@def v2()= @[
~+/{ 
@[~~320 
~*~~02.25 
]
~~0.5
}
~*0.5
Tanh()
~~L 
~*~~10 
~*~~0.5 
~~L 
~*0.50
]

@def sines() =  @[~+/{@[v1() ~*~~0.3] @[v2() ~*~~0.1]} ~*0.1 @[~~L] ]

@main @[techno() ~*sines()]


`,
      language: "cpp",
      theme: "vs-dark",
      automaticLayout: true,
    });
    function handleEditorChange() {
    if (!engine || !yModule) {
      console.warn("❌ engine / module error");
      return;
    }
    const code = editor.getValue();

    const ptr = yModule.allocateUTF8(code);
    const builder = yModule._y_engine_try_parse_to_builder(engine, ptr);
    yModule._free(ptr);

    const hasValue = yModule._y_optional_dsp_build_fn_has_value(builder);

    if (hasValue === true) {
      console.log("✅ DSP parsed successfully");
      yModule._y_engine_dsp_set(engine, builder);

      const sampleRate = 48000;
      const blockSize = 512;
      const channels = 1;
      yModule._y_engine_dsp_node_prepare(engine, channels, blockSize, sampleRate);
      
      yModule._y_optional_dsp_build_fn_free(builder);
    } else {
      const errPtr = yModule._y_engine_get_new_last_error(engine);
      const err = yModule.UTF8ToString(errPtr);
      console.warn("❌ DSP error:", err);

      yModule._y_optional_dsp_build_fn_free(builder);
    }
  }

     editor.onDidChangeModelContent(handleEditorChange);
     window.handleEditorChange = handleEditorChange;
  });



  function startAudio() {
    if (isAudioRunning) return;
    isAudioRunning = true;

    audioContext = new AudioContext();
    console.log("AudioContext started:", audioContext);

    // Load WASM Module
    Module().then(mod => {
      yModule = mod;
      engine = yModule._y_engine_new();

      console.log(Object.keys(yModule).filter(k => k.startsWith('_')));

      const sampleRate = 48000;
      const blockSize = 512;
      const channels = 1;

      yModule._y_engine_dsp_node_prepare(engine, channels, blockSize, sampleRate);

      bufferIn = yModule._malloc(blockSize * 4);
      bufferOut = yModule._malloc(blockSize * 4);

      scriptNode = audioContext.createScriptProcessor(blockSize, 1, 1);

      scriptNode.onaudioprocess = function (e) {
        const output = e.outputBuffer.getChannelData(0);

        yModule._y_engine_dsp_node_process(engine, bufferIn, bufferOut);

        const outputView = new Float32Array(yModule.HEAPF32.buffer, bufferOut, blockSize);
        
        for (let i = 0; i < blockSize; i++) {
          output[i] = outputView[i];
        }

        drawScope(output);
      };

      scriptNode.connect(audioContext.destination);

      document.getElementById('startAudio').disabled = true;
      document.getElementById('stopAudio').disabled = false;

      console.log("🔊 Audio running...");

      if (window.handleEditorChange) {
        window.handleEditorChange();
      }

    });
  }

  function stopAudio() {
    if (!isAudioRunning) return;
    if (!yModule) return;

    isAudioRunning = false;

    if (scriptNode) {
      scriptNode.disconnect();
      scriptNode = null;
    }

    if (audioContext) {
      audioContext.close();
      audioContext = null;
    }

    if (engine && yModule) {
      if (bufferIn) {
      yModule._free(bufferIn);
      bufferIn = null;
    }
    if (bufferOut) {
      yModule._free(bufferOut);
      bufferOut = null;
    }

      yModule._y_engine_free(engine);
      engine = null;
      yModule = null;
    }

    document.getElementById('startAudio').disabled = false;
    document.getElementById('stopAudio').disabled = true;

    clearScope();
    console.log("🛑 Audio stopped.");
  }

  document.getElementById("startAudio").addEventListener("click", startAudio);
  document.getElementById("stopAudio").addEventListener("click", stopAudio);

  // Simple oscilloscope drawing
  const scopeCanvas = document.getElementById('scope');
  const scopeCtx = scopeCanvas.getContext('2d');

  // Adjust canvas size for devicePixelRatio
  function resizeScope() {
    const width = scopeCanvas.clientWidth;
    const height = scopeCanvas.clientHeight;
    const dpr = window.devicePixelRatio || 1;

    scopeCanvas.width = width * dpr;
    scopeCanvas.height = height * dpr;
    scopeCtx.scale(dpr, dpr);
  }
  resizeScope();
  window.addEventListener('resize', resizeScope);

  // function drawScope(buffer) {
  //   const width = scopeCanvas.clientWidth;
  //   const height = scopeCanvas.clientHeight;

  //   scopeCtx.clearRect(0, 0, width, height);
  //   scopeCtx.strokeStyle = '#0f0';
  //   scopeCtx.lineWidth = 2;
  //   scopeCtx.beginPath();

  //   const step = Math.ceil(buffer.length / width);
  //   for (let i = 0; i < width; i++) {
  //     const sample = buffer[i * step] || 0;
  //     const y = (1 - (sample + 1) / 2) * height; // normalize -1..1 to canvas Y
  //     if (i === 0) {
  //       scopeCtx.moveTo(i, y);
  //     } else {
  //       scopeCtx.lineTo(i, y);
  //     }
  //   }
  //   scopeCtx.stroke();
  // }

  function drawScope(buffer) {
  const width = scopeCanvas.clientWidth;
  const height = scopeCanvas.clientHeight;

  scopeCtx.clearRect(0, 0, width, height);
  scopeCtx.strokeStyle = '#0f0';
  scopeCtx.lineWidth = 2;
  scopeCtx.beginPath();

  const step = buffer.length / width;

  for (let i = 0; i < width; i++) {
    const idx = i * step;
    // simple floor to get sample index
    const sample = buffer[Math.floor(idx)] || 0;
    const y = (1 - (sample + 1) / 2) * height; // normalize -1..1 to canvas Y
    if (i === 0) {
      scopeCtx.moveTo(i, y);
    } else {
      scopeCtx.lineTo(i, y);
    }
  }
  scopeCtx.stroke();
}

  function clearScope() {
    const width = scopeCanvas.clientWidth;
    const height = scopeCanvas.clientHeight;
    scopeCtx.clearRect(0, 0, width, height);
  }

  window.addEventListener("beforeunload", () => {
    if (engine && yModule) {
      yModule._y_engine_free(engine);
    }
  });
</script>

</body>
</html>
